<!DOCTYPE html>
<html>
<head>
    <title>ttt</title>
    <meta charset="utf-8"/>
    <style type="text/css">
        body {
            font-family: "Fira", Helvetica, Arial, sans-serif;
            margin: 0;
            text-align: center;
            color: #6b6b6b;
        }
        canvas {
            border: 1px solid #d0d0d0;
            background-color: #fff;
        }
        .everything {
            margin: auto;
        }
    </style>
</head>
<body onload="">
    <canvas id="canvas" ></canvas>

    <script src="jquery-3.3.1.min.js" type="text/javascript"></script>
    <script type="text/javascript">

        const KeyProcessingOptionMoving = "moving";
        const KeyProcessingOptionTalking = "talking";

        function randomIntFromInterval(min, max) { // min and max included 
            return Math.floor(Math.random() * (max - min + 1) + min)
        }

        $(document).ready(function () {

            var model = new TilesModel();
        });

        var TileModel = function(x,y) {
            var self = this;

            self.x = x;
            self.y = y;

            self.image = null;
            self.passable = true;
            self.climbable = false;

            self.IsPassable = function() {
                return self.passable;
            };
            self.IsClimbable = function() {
                return self.climbable;
            };

            // var random = randomIntFromInterval(1,20);
            // if(random == 1) {
            //     self.image = "brick01.png";
            // }
            // else if(random == 2) {
            //     self.image = "pavement02.png";
            // }
            // else {
            //     self.image = "pavement01.png";
            // }
        };

        var KeyProcessor = function(topLevel) {
            var self = this;

            self.topLevel = topLevel;
            self.keyProcessingChoice = KeyProcessingOptionMoving;

            self.movementProcessor = new MovementProcessor(self.topLevel);
            
            self.ProcessKeyPress = function(key) {
                if(self.keyProcessingChoice == KeyProcessingOptionMoving) {
                    self.movementProcessor.ProcessKeyPress(key);
                } else if(self.keyProcessingChoice == KeyProcessingOptionTalking) {

                }
            }
        }

        var MovementProcessor = function(topLevel) {
            var self = this;

            self.topLevel = topLevel;
            self.movementIncrement = 0; // 1 or 2 depending on walking or running
            self.running = false;
            self.climbing = false;

            self.ProcessKeyPress = function(key) {

                let movingToX = self.topLevel.currentX;
                let movingToY = self.topLevel.currentY;

                self.movementIncrement = self.running ? 2 : 1;

                // when running we move two tiles - we need to get the tile between where we currently are
                // and where we going, to confirm it is something we can pass through
                let tileSkipping = null;
                let skippingX = self.topLevel.currentX;
                let skippingY = self.topLevel.currentY;
                if(self.running) {
                    
                    if(key === 'w') {
                        skippingY = skippingY - 1;
                    } else if(key === 'a') {
                        skippingX = skippingX - 1;
                    } else if(key === 's') {
                        skippingY = skippingY + 1;
                    } else if(key === 'd') {
                        skippingX = skippingX + 1;
                    }
                    tileSkipping = self.topLevel.GetTileAt(skippingX,skippingY);
                    // if we can't pass over this tile then we crash/stop running
                    if(tileSkipping && tileSkipping.IsPassable()) {

                    } else {
                        self.running = false;
                        return;
                    }
                }

                let isMoving = false;
                if(key === 'w') {
                    movingToY = movingToY - self.movementIncrement;
                    isMoving = true;
                } else if(key === 'a') {
                    movingToX = movingToX - self.movementIncrement;
                    isMoving = true;
                } else if(key === 's') {
                    movingToY = movingToY + self.movementIncrement;
                    isMoving = true;
                } else if(key === 'd') {
                    movingToX = movingToX + self.movementIncrement;
                    isMoving = true;
                } else if(key === 'r') {
                    self.running = !self.running;
                } else if(key === 'c') {
                    self.climbing = true;
                    // starting climbing stops you running
                    self.running = false;
                }

                // if the key press was intended to generate movement then we see if can move
                // is there a tile in that direction at all?
                // if so, is it one that we can move onto?
                if(isMoving) {
                    var moveToTile = self.topLevel.GetTileAt(movingToX,movingToY);

                    if(moveToTile) {
                        if(moveToTile.IsPassable()) {
                            self.topLevel.currentX = movingToX;
                            self.topLevel.currentY = movingToY;
                        } else if(moveToTile.IsClimbable() && self.climbing) {
                            self.topLevel.currentX = movingToX;
                            self.topLevel.currentY = movingToY;
                            self.climbing = false;
                        } else {
                            // if we're running and we crash when trying to go to the second step, stop us on the first step instead
                            if(self.running) {
                                self.topLevel.currentX = skippingX;
                                self.topLevel.currentY = skippingY;
                                self.running = false;
                            }
                        }
                    } else {
                        // they tried to move off the edge of the world <<madness>>
                        self.climbing = false;
                        if(self.running) {
                            self.topLevel.currentX = skippingX;
                            self.topLevel.currentY = skippingY;
                            self.running = false;
                        }
                    }
                }

            };
        }

        var TilesModel = function() {
            var self = this;

            self.keyProcessor = new KeyProcessor(this);

            self.canvas = document.getElementById('canvas');
            self.ctx = self.canvas.getContext('2d');
            self.loader = null;         // loaded images
            self.images = [];

            self.rows = [];
            self.tileHeight = 40;
            self.tileWidth = 30;
            self.startDrawingX = 0;     // the index of the first tile on the canvas
            self.startDrawingY = 0;     
            self.tilesToDrawFromX = 0;  // how many tiles between the edge and the center
            self.tilesToDrawFromY = 0;
            self.totalTilesInX = 0;     // how many tiles currently on the screen
            self.totalTilesInY = 0;
            self.currentX = 20;         // the tile index position of the user
            self.currentY = 3;
            self.centerTileAtX = 0;     // where to start drawing the center tile (the coordinates on the canvas)
            self.centerTileAtY = 0;
            self.maxX = 1000;
            self.maxY = 1000;


            self.GenerateTiles = function() {
                for(let y = 0; y < self.maxY; y++) {
                    let col = [];

                    for(let x = 0; x < self.maxX; x++) {
                        let tile = new TileModel(x,y);
                        col.push(tile);
                    }
                    self.rows.push(col);
                }
                self.rows[0][0].image = "brick01.png";
                self.rows[0][0].passable = false;
                self.rows[5][19].image = "brick01.png";
                self.rows[5][19].passable = false;
                self.rows[5][19].climbable = true;
            };

            self.GetTileAt = function(tileX,tileY) {
                if(tileX < 0 || tileX >= self.maxX) {
                    return null;
                }
                if(tileY < 0 || tileY >= self.maxY) {
                    return null;
                }
                return self.rows[tileY][tileX];
            }

            self.LoadImages = function(arr, callback) {
                //this.images = {};
                var loadedImageCount = 0;

                // Make sure arr is actually an array and any other error checking
                for (var i = 0; i < arr.length; i++){
                    var img = new Image();
                    img.onload = imageLoaded;
                    img.src = arr[i];
                    //this.images[arr[i]] = img;
                    self.images.push(img);
                }

                function imageLoaded(e) {
                    loadedImageCount++;
                    if (loadedImageCount >= arr.length) {
                        callback();
                    }
                }
            };

            

            self.DrawLoop = function() {
                //console.log("starting draw loop")
                self.ctx.fillStyle = 'white';
                self.ctx.fillRect(0, 0, self.canvasWidth, self.canvasHeight);

                // self.ctx.beginPath();
                // self.ctx.strokeStyle = "#ff0000";
                // self.ctx.rect(20, 20, 100, 100);
                // self.ctx.stroke();

                let startDrawingFromTileX = self.currentX - self.tilesToDrawFromX;
                let startDrawingFromTileY = self.currentY - self.tilesToDrawFromY;

                // var img = new Image();
                // img.src = 'images/brick01.png';
                // img.load(function() {
                //     console.log('Image Loaded');
                // });

                self.ctx.save();
                self.ctx.beginPath();
                self.ctx.strokeStyle = "#ff0000";
                self.ctx.fillStyle = 'black';
                for(let y = 0; y < self.totalTilesInY; y++) {
                    //console.log("drawing y of "+y)

                    for(let x = 0; x < self.totalTilesInX; x++) {
                        
                        //console.log("drawing x,y of "+x+","+y);


                        var drawAtX = self.startDrawingX + (x * self.tileWidth);
                        var drawAtY = self.startDrawingY + (y * self.tileHeight);

                        //console.log("x = " + drawAtX + ", y = " + drawAtY)
                        self.ctx.rect(drawAtX, drawAtY, self.tileWidth, self.tileHeight);

                        var tileToDraw = self.GetTileAt(startDrawingFromTileX+x,startDrawingFromTileY+y);
                        if(tileToDraw) {
                            if(tileToDraw.image) {
                                //console.log("drawing image " + tileToDraw.image + " at " + (drawAtX) + "," + (drawAtY))
                                self.ctx.drawImage(self.images[0], drawAtX, drawAtY);
                            }
                            self.ctx.textBaseline = "hanging";
                            self.ctx.fillText((startDrawingFromTileX+x)+','+(startDrawingFromTileY+y), drawAtX, drawAtY);
                            //console.log("got a tile at " + (startDrawingFromTileX+x) + "," + (startDrawingFromTileY+y));
                        } else {
                            //console.log("no tile at " + (startDrawingFromTileX+x) + "," + (startDrawingFromTileY+y));
                            self.ctx.fillRect(drawAtX, drawAtY, self.tileWidth, self.tileHeight);
                        }
                    }
                }
                self.ctx.stroke();
                self.ctx.restore();
                //console.log("ended draw loop")

                // draw the player
                self.ctx.save();
                self.ctx.beginPath();
                self.ctx.fillStyle = 'yellow';
                self.ctx.fillRect(self.centerTileAtX, self.centerTileAtY, self.tileWidth, self.tileHeight);
                self.ctx.stroke();
                self.ctx.restore();

                window.requestAnimationFrame(self.DrawLoop);
                //setTimeout(function() { self.DrawLoop() }, 1000);
            };

            self.ResizeHandler = function() {
                console.log("in resize handler");
                self.canvas.width = window.innerWidth - 100;
                self.canvas.height = window.innerHeight - 100;
                self.CalculateDrawSizes();
            }

            self.CalculateDrawSizes = function() {
                // get the map size
                var width = document.getElementById('canvas').offsetWidth;
                var height = document.getElementById('canvas').offsetHeight;
                self.canvasWidth = width;
                self.canvasHeight = height;
                console.log("width by height is " + width + " by " + height);
                // how many tiles wide/high is our canvas?
                var tilesInWidth = Math.ceil(width / self.tileWidth);
                var tilesInHeight = Math.ceil(height / self.tileHeight);
                // where is our start drawing point?
                // and
                // from the center tile, how far back (in tiles) do we start drawing?
                var centerTileAt = (width/2) - (self.tileWidth /2);
                self.centerTileAtX = centerTileAt;
                self.tilesToDrawFromX = Math.ceil(centerTileAt / self.tileWidth);
                self.startDrawingX = centerTileAt - (self.tilesToDrawFromX * self.tileWidth);
                self.totalTilesInX = (self.tilesToDrawFromX * 2) + 1;
                console.log("self.tilesToDrawFromX: " + self.tilesToDrawFromX);
                console.log("self.startDrawingX: " + self.startDrawingX);
                console.log("self.totalTilesInX: " + self.totalTilesInX);

                var centerTileAt = (height/2) - (self.tileHeight /2);
                self.centerTileAtY = centerTileAt;
                self.tilesToDrawFromY = Math.ceil(centerTileAt / self.tileHeight);
                self.startDrawingY = centerTileAt - (self.tilesToDrawFromY * self.tileHeight);
                self.totalTilesInY = (self.tilesToDrawFromY * 2) + 1;
                console.log("self.tilesToDrawFromY: " + self.tilesToDrawFromY);
                console.log("self.startDrawingY: " + self.startDrawingY);
                console.log("self.totalTilesInY: " + self.totalTilesInY);

            };

            self.ProcessKeyDown = function(event) {
                //console.log(event.key);
                self.keyProcessor.ProcessKeyPress(event.key);
            }

            self.Initialize = function() {
                // get canvas the right size
                self.ResizeHandler();
                // hook up resize handler
                window.addEventListener('resize', self.ResizeHandler, false);
                window.addEventListener('keydown', self.ProcessKeyDown, false);
                // make some dummy tiles
                self.GenerateTiles();
                // figure out how many etc tiles we are drawing
                self.CalculateDrawSizes();
                //window.requestAnimationFrame(self.DrawLoop());
                //self.DrawLoop();
                self.loader = self.LoadImages(['images/brick01.png'], function() {
                    //self.DrawLoop();
                    window.requestAnimationFrame(self.DrawLoop);
                });
            };
            self.Initialize();
        };
    </script>
</body>
</html>